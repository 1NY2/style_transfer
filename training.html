<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾åƒé£æ ¼è¿ç§» - è®­ç»ƒè¿‡ç¨‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .images-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .images-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 768px) {
            .images-grid {
                grid-template-columns: 1fr;
            }
        }

        .image-card {
            text-align: center;
        }

        .card-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .training-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .progress-container {
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        .final-result-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .final-result-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .final-result-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-item {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .result-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
        }

        .result-info {
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
            color: #333;
        }

        .loss-chart {
            height: 200px;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        #loss-canvas{
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid #eee;
        }

        .hidden {
            display: none;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateX(200%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .notification.error {
            background: linear-gradient(135deg, #f44336, #da190b);
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.stop {
            background: linear-gradient(135deg, #f44336, #da190b);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ¨ å›¾åƒé£æ ¼è¿ç§»</h1>
            <p class="subtitle">è®­ç»ƒè¿‡ç¨‹å¯è§†åŒ–</p>
        </header>

        <button class="back-btn" id="back-btn">â† è¿”å›å‚æ•°è®¾ç½®</button>

        <section class="images-section">
            <div class="images-grid">
                <div class="image-card">
                    <h2 class="card-title">å†…å®¹å›¾ç‰‡</h2>
                    <img id="content-display" src="" alt="Content Image" class="image-preview">
                </div>
                <div class="image-card">
                    <h2 class="card-title">é£æ ¼å›¾ç‰‡</h2>
                    <img id="style-display" src="" alt="Style Image" class="image-preview">
                </div>
            </div>
        </section>

        <section class="training-section">
            <h2 class="section-title">è®­ç»ƒè¿›åº¦</h2>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="status-info">
                    <span id="current-status">å‡†å¤‡è®­ç»ƒ...</span>
                    <span id="time-elapsed">è€—æ—¶: 0s</span>
                </div>
            </div>

            <div class="controls">
                <button id="start-stop-btn" class="btn">å¼€å§‹è®­ç»ƒ</button>
            </div>

            <div class="loss-chart" id="loss-chart">
                <canvas id="loss-canvas"></canvas>
            </div>

            <!-- æœ€ç»ˆç»“æœå±•ç¤ºåŒºåŸŸ -->
            <div id="final-result-section" class="final-result-section hidden">
                <h3 class="final-result-title">æœ€ç»ˆç»“æœ</h3>
                <img id="final-result-image" class="final-result-image" src="" alt="Final Result">
                <div id="final-result-info" style="margin-top: 10px;"></div>
            </div>

            <h2 class="section-title">ä¸­é—´ç»“æœ</h2>
            <div class="results-grid" id="results-grid">
            </div>
        </section>
    </div>

    <div class="notification hidden" id="notification"></div>

    <script>
        // å…¨å±€å˜é‡
        let trainingData = null;
        let isTraining = false;
        let abortController = null;
        let startTime = null;
        let lossData = [];
        let currentEpoch = 0;

        // DOM å…ƒç´ 
        const contentDisplay = document.getElementById('content-display');
        const styleDisplay = document.getElementById('style-display');
        const progressFill = document.getElementById('progress-fill');
        const currentStatus = document.getElementById('current-status');
        const timeElapsed = document.getElementById('time-elapsed');
        const resultsGrid = document.getElementById('results-grid');
        const notification = document.getElementById('notification');
        const backBtn = document.getElementById('back-btn');
        const lossCanvas = document.getElementById('loss-canvas');
        const ctx = lossCanvas.getContext('2d');
        const startStopBtn = document.getElementById('start-stop-btn');
        const finalResultSection = document.getElementById('final-result-section');
        const finalResultImage = document.getElementById('final-result-image');
        const finalResultInfo = document.getElementById('final-result-info');
        const lossChart = document.getElementById('loss-chart');

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', initTrainingPage);

        function initTrainingPage() {
            console.log('Initializing training page...');
            // ä» localStorage è·å–è®­ç»ƒæ•°æ®
            const data = localStorage.getItem('styleTransferData');
            if (!data) {
                showNotification('æœªæ‰¾åˆ°è®­ç»ƒæ•°æ®ï¼Œè¯·å…ˆè®¾ç½®å‚æ•°', 'error');
                setTimeout(() => {
                    window.location.href = 'input.html';
                }, 3000);
                return;
            }

            try {
                trainingData = JSON.parse(data);

                // æ˜¾ç¤ºå›¾ç‰‡
                contentDisplay.src = trainingData.contentImage;
                styleDisplay.src = trainingData.styleImage;

                // ç¡®ä¿ Canvas å…ƒç´ å·²æ­£ç¡®åˆå§‹åŒ–
                setTimeout(() => {
                    if (lossCanvas) {
                        // è®¾ç½® Canvas å°ºå¯¸ä¸ºå®¹å™¨çš„å®é™…å°ºå¯¸
                        lossCanvas.width = lossChart.offsetWidth;
                        lossCanvas.height = lossChart.offsetHeight;

                         // æ·»åŠ è°ƒè¯•ä¿¡æ¯
                        console.log('Canvas initialized:', {
                            width: lossCanvas.width,
                            height: lossCanvas.height
                        });
                    }
                }, 100);
            } catch (e) {
                showNotification('è®­ç»ƒæ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¯·é‡æ–°è®¾ç½®å‚æ•°', 'error');
                setTimeout(() => {
                    window.location.href = 'input.html';
                }, 3000);
            }
        }

        // è¿”å›æŒ‰é’®äº‹ä»¶
        backBtn.addEventListener('click', () => {
            if (isTraining) {
                if (!confirm('ç¡®å®šè¦è¿”å›å‚æ•°è®¾ç½®é¡µé¢å—ï¼Ÿè¿™å°†åœæ­¢å½“å‰è®­ç»ƒã€‚')) {
                    return;
                }
            }
            stopTraining();
            window.location.href = 'input.html';
        });

        // å¼€å§‹/åœæ­¢æŒ‰é’®äº‹ä»¶
        startStopBtn.addEventListener('click', () => {
            if (isTraining) {
                stopTraining();
            } else {
                startTraining();
            }
        });

        // å¼€å§‹è®­ç»ƒ
        async function startTraining() {
            console.log('Starting training...');
            if (isTraining) return;

            window.jsonBuffer = '';

            isTraining = true;
            startStopBtn.textContent = 'åœæ­¢è®­ç»ƒ';
            startStopBtn.classList.add('stop');

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            currentStatus.textContent = 'æ­£åœ¨è¿æ¥æœåŠ¡å™¨...';

            // åˆå§‹åŒ–è®­ç»ƒçŠ¶æ€
            startTime = Date.now();
            lossData = [];
            currentEpoch = 0;

            // é‡ç½®ç•Œé¢
            progressFill.style.width = '0%';
            progressFill.style.transition = 'none';
            resultsGrid.innerHTML = '';
            currentStatus.textContent = 'å¼€å§‹è®­ç»ƒ...';
            timeElapsed.textContent = 'è€—æ—¶: 0s';

            // éšè—æœ€ç»ˆç»“æœ
            finalResultSection.classList.add('hidden');

            try {
                // å‘é€è®­ç»ƒè¯·æ±‚åˆ°åç«¯
                await trainStyleTransfer();
            } catch (error) {
                console.error('è®­ç»ƒå‡ºé”™:', error);
                showNotification('è®­ç»ƒè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ' + error.message, 'error');
                stopTraining();
            }
        }

        // åœæ­¢è®­ç»ƒ
        function stopTraining() {
            isTraining = false;
            startStopBtn.textContent = 'å¼€å§‹è®­ç»ƒ';
            startStopBtn.classList.remove('stop');

            if (abortController) {
                abortController.abort();
            }

            currentStatus.textContent = 'è®­ç»ƒå·²åœæ­¢';

            window.jsonBuffer = '';
        }

        // è°ƒç”¨åç«¯APIè¿›è¡Œè®­ç»ƒ
        async function trainStyleTransfer() {
            abortController = new AbortController();

            try {
                const response = await fetch('/train', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contentImage: trainingData.contentImage,
                        styleImage: trainingData.styleImage,
                        contentWeight: trainingData.contentWeight,
                        styleWeight: trainingData.styleWeight,
                        epochs: trainingData.epochs
                    }),
                    signal: abortController.signal
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);

                if (!response.ok) {
                    const errorMessage = `æœåŠ¡å™¨é”™è¯¯: ${response.status} ${response.statusText}`;
                    throw new Error(errorMessage);
                }

                // ç¡®ä¿å“åº”æ˜¯æ–‡æœ¬ç±»å‹
                if (response.headers.get('content-type')?.includes('text/plain')) {
                    console.log('Response is text/plain, processing stream...');
                }

                // æ·»åŠ è°ƒè¯•ï¼šæ£€æŸ¥å“åº”ä½“æ˜¯å¦å¯è¯»
                console.log('Response body readable:', response.body !== null);

                if (!response.body) {
                    throw new Error('æœåŠ¡å™¨å“åº”ä¸æ”¯æŒæµå¼è¯»å–');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    console.log('Received chunk:', chunk);  // æ·»åŠ è°ƒè¯•è¾“å‡º

                    processTrainingOutput(chunk);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    currentStatus.textContent = 'è®­ç»ƒå·²å–æ¶ˆ';
                } else {
                    console.error('è®­ç»ƒè¯·æ±‚å¤±è´¥:', error);
                    showNotification('è®­ç»ƒè¯·æ±‚å¤±è´¥: ' + error.message, 'error');
                    currentStatus.textContent = 'è®­ç»ƒå¤±è´¥: ' + error.message;
                }
                stopTraining();
            }
        }

        // å¤„ç†è®­ç»ƒè¾“å‡º
        function processTrainingOutput(data) {
            console.log('Processing data chunk, length:', data.length);

            // ç¼“å†²åŒºç”¨äºå­˜å‚¨ä¸å®Œæ•´çš„JSON
            if (!window.jsonBuffer) {
                window.jsonBuffer = '';
            }

            // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
            window.jsonBuffer += data;

            // åˆ†å‰²å®Œæ•´çš„JSONå¯¹è±¡
            let startIndex = 0;
            while (startIndex < window.jsonBuffer.length) {
                // æŸ¥æ‰¾JSONå¯¹è±¡çš„å¼€å§‹å’Œç»“æŸ
                const openBraceIndex = window.jsonBuffer.indexOf('{', startIndex);
                if (openBraceIndex === -1) {
                    break;
                }

                let braceCount = 0;
                let endIndex = -1;

                // å¯»æ‰¾åŒ¹é…çš„é—­åˆå¤§æ‹¬å·
                for (let i = openBraceIndex; i < window.jsonBuffer.length; i++) {
                    if (window.jsonBuffer[i] === '{') {
                        braceCount++;
                    } else if (window.jsonBuffer[i] === '}') {
                        braceCount--;
                        if (braceCount === 0) {
                            endIndex = i;
                            break;
                        }
                    }
                }

                // å¦‚æœæ‰¾åˆ°äº†å®Œæ•´çš„JSONå¯¹è±¡
                if (endIndex !== -1) {
                    const jsonString = window.jsonBuffer.substring(openBraceIndex, endIndex + 1);

                    try {
                        const output = JSON.parse(jsonString);
                        console.log('Received output:', output);

                        switch(output.type) {
                            case 'progress':
                                updateProgress(output);
                                break;
                            case 'result':
                                addResultPreview(output);
                                break;
                            case 'complete':
                                showFinalResult(output);
                                stopTraining();
                                break;
                            case 'message':
                                if (output.text === 'Early stopping!') {
                                    currentStatus.textContent = 'æå‰åœæ­¢è®­ç»ƒ';
                                    showNotification('è®­ç»ƒæå‰åœæ­¢', 'success');
                                    stopTraining();
                                }
                                break;
                            case 'error':
                                currentStatus.textContent = 'è®­ç»ƒå‡ºé”™ï¼š' + output.message;
                                showNotification(output.message, 'error');
                                stopTraining();
                                break;
                        }

                        // ç§»åŠ¨èµ·å§‹ç´¢å¼•åˆ°ä¸‹ä¸€ä¸ªå¯èƒ½çš„å¯¹è±¡å¼€å§‹ä½ç½®
                        startIndex = endIndex + 1;
                    } catch (e) {
                        console.error('Failed to parse JSON:', jsonString, e);
                        startIndex = openBraceIndex + 1;
                    }
                } else {
                    // æ²¡æœ‰æ‰¾åˆ°å®Œæ•´çš„JSONå¯¹è±¡ï¼Œä¿ç•™å‰©ä½™éƒ¨åˆ†åœ¨ç¼“å†²åŒºä¸­
                    break;
                }
            }

            // ä¿ç•™æœªå¤„ç†çš„éƒ¨åˆ†åœ¨ç¼“å†²åŒºä¸­
            if (startIndex < window.jsonBuffer.length) {
                window.jsonBuffer = window.jsonBuffer.substring(startIndex);
            } else {
                window.jsonBuffer = '';
            }
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(data) {
            currentEpoch = data.epoch;

            // æ›´æ–°è¿›åº¦æ¡
            const progress = (currentEpoch / trainingData.epochs) * 100;
            progressFill.style.width = `${progress}%`;
            progressFill.style.transition = 'width 0.3s ease';

            // æ›´æ–°æ—¶é—´
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            timeElapsed.textContent = `è€—æ—¶: ${elapsed}s`;

            // æ›´æ–°æŸå¤±æ•°æ®
            lossData.push({epoch: currentEpoch, loss: data.loss});

            // æ›´æ–°çŠ¶æ€æ–‡æœ¬
            currentStatus.textContent = `è®­ç»ƒä¸­... Epoch: ${currentEpoch}/${trainingData.epochs}, Loss: ${data.loss.toFixed(4)}`;

            // ç»˜åˆ¶æŸå¤±å›¾è¡¨
            drawLossChart();

            // è°ƒè¯•ä¿¡æ¯
            console.log(`Updated progress: ${progress}%, Epoch: ${currentEpoch}, Loss: ${data.loss}`);
        }

        // æ·»åŠ ç»“æœé¢„è§ˆ
        function addResultPreview(data) {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';

            resultItem.innerHTML = `
                <img src="${data.image}" alt="Result ${data.epoch}" class="result-image">
                <div class="result-info">
                    <div>Epoch: ${data.epoch}</div>
                    <div>Loss: ${data.loss.toFixed(4)}</div>
                </div>
            `;

            resultsGrid.prepend(resultItem);
        }

        // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
        function showFinalResult(data) {
            // æ˜¾ç¤ºæœ€ç»ˆç»“æœåŒºåŸŸ
            finalResultSection.classList.remove('hidden');
            finalResultImage.src = data.image;
            finalResultInfo.innerHTML = `<strong>Loss:</strong> ${data.loss.toFixed(4)}`;

            // åŒæ—¶ä¹Ÿåœ¨ä¸­é—´ç»“æœä¸­æ·»åŠ æœ€ç»ˆç»“æœ
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';

            resultItem.innerHTML = `
                <img src="${data.image}" alt="Final Result" class="result-image">
                <div class="result-info">
                    <div>æœ€ç»ˆç»“æœ</div>
                    <div>Loss: ${data.loss.toFixed(4)}</div>
                </div>
            `;

            resultsGrid.prepend(resultItem);
        }

        // ç»˜åˆ¶æŸå¤±å›¾è¡¨
        function drawLossChart() {
            if (lossData.length === 0) return;

            // ç¡®ä¿ Canvas å­˜åœ¨ä¸”æœ‰å°ºå¯¸
            if (!ctx || !lossCanvas.width || !lossCanvas.height) {
                console.warn('Canvas not ready for drawing');
                return;
            }

            const width = lossCanvas.width;
            const height = lossCanvas.height;
            const padding = 40; // å›¾è¡¨è¾¹è·

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);

            // è®¾ç½®èƒŒæ™¯è‰²
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // è®¡ç®—æœ€å¤§æŸå¤±å€¼å’Œæœ€å°æŸå¤±å€¼ç”¨äºç¼©æ”¾
            const maxLoss = Math.max(...lossData.map(d => d.loss));
            const minLoss = Math.min(...lossData.map(d => d.loss));
            const lossRange = maxLoss - minLoss || 1;

            // è®¡ç®—æœ€å¤§epochç”¨äºXè½´
            const maxEpoch = Math.max(...lossData.map(d => d.epoch));

            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;

            // æ°´å¹³ç½‘æ ¼çº¿
            const horizontalLines = 5;
            for (let i = 0; i <= horizontalLines; i++) {
                const y = padding + (height - 2 * padding) * (i / horizontalLines);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // å‚ç›´ç½‘æ ¼çº¿
            const verticalLines = Math.min(10, lossData.length - 1);
            for (let i = 0; i <= verticalLines; i++) {
                const x = padding + (width - 2 * padding) * (i / verticalLines);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }

            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#495057';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Xè½´
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            // Yè½´
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();

            // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
            ctx.fillStyle = '#495057';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            // Xè½´æ ‡ç­¾
            ctx.fillText('Epoch', width / 2, height - 3);

            // Yè½´æ ‡ç­¾ (æ—‹è½¬90åº¦)
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.restore();

            // Xè½´åˆ»åº¦å€¼
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i <= Math.min(10, lossData.length - 1); i++) {
                const epochStep = Math.ceil(maxEpoch / Math.min(10, lossData.length - 1));
                const epochValue = i * epochStep;
                const x = padding + (width - 2 * padding) * (epochValue / maxEpoch);
                ctx.fillText(epochValue.toString(), x, height - padding + 5);
            }

            // Yè½´åˆ»åº¦å€¼
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= 5; i++) {
                const lossValue = minLoss + (lossRange) * (1 - i / 5);
                const y = padding + (height - 2 * padding) * (i / 5);
                ctx.fillText(lossValue.toFixed(2), padding - 5, y);
            }

            // ç»˜åˆ¶æŸå¤±æ›²çº¿
            if (lossData.length > 1) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();

                lossData.forEach((data, index) => {
                    const x = padding + ((width - 2 * padding) * (data.epoch / maxEpoch));
                    const y = padding + (height - 2 * padding) * (1 - (data.loss - minLoss) / lossRange);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // ç»˜åˆ¶æ•°æ®ç‚¹
                ctx.fillStyle = '#667eea';
                lossData.forEach((data) => {
                    const x = padding + ((width - 2 * padding) * (data.epoch / maxEpoch));
                    const y = padding + (height - 2 * padding) * (1 - (data.loss - minLoss) / lossRange);
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('è®­ç»ƒæŸå¤±å˜åŒ–å›¾', width / 2, 20);
        }

        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message, type) {
            notification.textContent = message;
            notification.className = `notification ${type} show`;

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // åˆå§‹åŒ–ç”»å¸ƒå¤§å°
        window.addEventListener('resize', () => {
            if (lossData.length > 0) {
                lossCanvas.width = lossCanvas.offsetWidth;
                lossCanvas.height = lossCanvas.offsetHeight;
                drawLossChart();
            }
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (isTraining) {
                stopTraining();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ
        window.addEventListener('DOMContentLoaded', () => {
            // ç­‰å¾…æ‰€æœ‰å…ƒç´ åŠ è½½å®Œæˆ
            setTimeout(() => {
                if (lossCanvas && lossChart) {
                    lossCanvas.width = lossChart.offsetWidth;
                    lossCanvas.height = lossChart.offsetHeight;
                    console.log('Canvas dimensions set:', lossCanvas.width, 'x', lossCanvas.height);
                }
            }, 200);
        });
    </script>
</body>
</html>
